package org.jd.gui.service.actions

import org.jd.gui.api.API
import org.jd.gui.api.model.Container
import org.jd.gui.api.model.Type
import org.jd.gui.service.actions.CopyQualifiedNameContextualActionsFactory.CopyQualifiedNameAction
import org.jd.gui.spi.ContextualActionsFactory
import java.awt.event.ActionEvent
import javax.swing.AbstractAction
import javax.swing.Action
import javax.swing.ImageIcon

val fileHeader = """/************************************************** //
                   | *    This file generated by jd-gui-export-to-dts   //
                   | **************************************************///
""".trimMargin()

fun String.toTypescriptType() = this.toTypescriptType(null)
fun String.toTypescriptType(path: String?): String {
    val isArray = this.contains("[]")
    val outType = (if (isArray) this.dropLast(2) else this)
    var type = when (outType.toLowerCase()) {
        "boolean" -> "boolean"
        "byte" -> "number /* byte */"
        "int" ->  "number /* int */"
        "long" -> "number /* long */"
        "float", "double" -> "number /* float */"
        "void" -> "void"
        else -> outType
    }

    val checkCallable = """\(.*\)""".toRegex()
    if (checkCallable.matches(type)) {
        type = type.split('(').first()
    }

    return if (isArray) {
        "Array<$type>"
    } else {
        type
    }
}

fun Type.Field.toDefinition(): String {
    val data = this.displayName.split(" : ")
    val name = data.first()
    val returnType = data.last().toTypescriptType()

    return "$name: $returnType"
}

fun Type.Method.toDefinition(): String {
    val data = this.displayName.split(" : ")
    val func = data.first()

    val findArgs = """\((.+?)\)""".toRegex()
    val matched = findArgs.find(func)

    val args = if (matched != null) {
        matched.groupValues[1].split(',').mapIndexed { index, _type ->
            var type = _type.trim()
            val name = if (type.contains("...")) {
                type = type.dropLast(3)
                "...arg$index"
            } else "arg$index"

            "$name: ${type.toTypescriptType()}"
        }
    } else listOf()

    val argsString = args.joinToString(", ")


    when (this.name) {
        "<init>" -> return "constructor($argsString)"
        "<clinit>" -> return "\$clinit(): any"
    }

    val returnType = data.last().toTypescriptType()

    return "${this.name}($argsString): $returnType"
}

class ExportToDtsContextualActionsFactory : ContextualActionsFactory {
    override fun make(api: API?, entry: Container.Entry?, fragment: String?): List<Action> {
        return listOf(ExportToDtsAction(api, entry, fragment) as Action)
    }

    class ExportToDtsAction(val api: API?, val entry: Container.Entry?, val fragment: String?) : AbstractAction() {
        val icon = ImageIcon(CopyQualifiedNameAction::class.java.classLoader.getResource("org/jd/gui/images/save.png"))
        var fullText = ""

        init {
            putValue(ContextualActionsFactory.GROUP_NAME, "Edit > CutCopyPaste")
            putValue(Action.NAME, "d.ts 파일로 출력하기")
            putValue(Action.SMALL_ICON, icon)
        }

        override fun actionPerformed(e: ActionEvent?) {

            val typeFactory = api!!.getTypeFactory(entry)

            if (typeFactory != null) {
                val type = typeFactory.make(api, entry, fragment)

                if (type != null) {

                    fullText += fileHeader
                    fullText += "\n\n"

                    fullText += "declare class ${type.name.split('/').last()} {\n\n"

                    fullText += "  /* fields */\n\n"

                    for (field in type.fields) {
                        fullText += "  "
                        fullText += field.toDefinition()
                        fullText += "\n"
                    }

                    fullText += "\n\n"

                    fullText += "  /* methods */\n\n"

                    for (method in type.methods) {
                        fullText += "  "
                        fullText += method.toDefinition()
                        fullText += "\n"
                    }

                    fullText += "}"
                    fullText += "\n\n"

                    // print and clear
                    print(fullText)
                    fullText = ""

                }
            }

        }


    }
}