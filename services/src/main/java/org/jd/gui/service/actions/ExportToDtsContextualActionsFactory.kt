package org.jd.gui.service.actions

import org.jd.gui.api.API
import org.jd.gui.api.model.Container
import org.jd.gui.api.model.Type
import org.jd.gui.service.actions.CopyQualifiedNameContextualActionsFactory.CopyQualifiedNameAction
import org.jd.gui.spi.ContextualActionsFactory
import java.awt.event.ActionEvent
import java.io.File
import javax.swing.*
import javax.swing.filechooser.FileNameExtensionFilter

val fileHeader = """/************************************************** //
                   | *    This file generated by jd-gui-export-to-dts   //
                   | **************************************************///
""".trimMargin()

fun String.toTypescriptType() = this.toTypescriptType(null)
fun String.toTypescriptType(path: String?): String {
    val isArray = this.contains("[]")
    val outType = (if (isArray) this.dropLast(2) else this)
    var type = when (outType.toLowerCase()) {
        "boolean" -> "boolean"

        "byte" -> "number /* byte */"
        "int" ->  "number /* int */"
        "short" -> "number /* short */"
        "long" -> "number /* long */"

        "float", "double" -> "number /* float */"

        "string" -> "string"

        "void" -> "void"
        else -> outType
    }

    val checkCallable = """\(.*\)""".toRegex()
    if (checkCallable.matches(type)) {
        type = type.split('(').first()
    }

    return if (isArray) {
        "Array<$type>"
    } else {
        type
    }
}

fun String.avoidConflictName(): String {
    return this.replace("$", "$$").replace('/', '$')
}

fun Type.Field.toDefinition(): String {
    val data = this.displayName.split(" : ")
    val name = data.first()
    val returnType = data.last().toTypescriptType()

    return "$name: $returnType"
}

fun Type.Method.toDefinition(): String {
    val data = this.displayName.split(" : ")
    val func = data.first()

    val findTypes = """L(.+?);""".toRegex()
    val typeFounds = findTypes.findAll(this.descriptor)

    for (type in typeFounds) {
        print("subList: ")
        println(type.groupValues.subList(1, type.groupValues.size))
        print("first group: ")
        println(type.groups[1])
    }

    val findArgs = """\((.+?)\)""".toRegex()
    val matched = findArgs.find(func)


    val args = if (matched != null) {
        matched.groupValues[1].split(',').mapIndexed { index, _type ->
            var type = _type.trim()
            val name = if (type.contains("...")) {
                type = type.dropLast(3)
                "...arg$index"
            } else "arg$index"

            "$name: ${type.toTypescriptType()}"
        }
    } else listOf()

    val argsString = args.joinToString(", ")


    when (this.name) {
        "<init>" -> return "constructor($argsString)"
        "<clinit>" -> return "\$clinit(): any"
    }

    val returnType = data.last().toTypescriptType()

    return "${this.name}($argsString): $returnType // ${this.descriptor}"
}

class ExportToDtsContextualActionsFactory : ContextualActionsFactory {
    override fun make(api: API?, entry: Container.Entry?, fragment: String?): List<Action> {
        return listOf(ExportToDtsAction(api, entry, fragment) as Action)
    }

    class ExportToDtsAction(val api: API?, val entry: Container.Entry?, val fragment: String?) : AbstractAction() {
        val icon = ImageIcon(CopyQualifiedNameAction::class.java.classLoader.getResource("org/jd/gui/images/save.png"))
        var fullText = ""

        init {
            putValue(ContextualActionsFactory.GROUP_NAME, "Edit > CutCopyPaste")
            putValue(Action.NAME, "d.ts 파일로 출력하기")
            putValue(Action.SMALL_ICON, icon)
        }

        private fun saveFile(typeName: String) {
            val frame = JFrame()
            val fc = JFileChooser()

            fc.dialogTitle = "저장할 위치를 선택하세요"

            val filter = FileNameExtensionFilter("Typescript Definition", "d.ts")
            fc.fileFilter = filter

            var newName = ""

            typeName.forEachIndexed { index, c ->
                newName += if (c.isUpperCase() && index != 0) "-${c.toLowerCase()}" else c.toLowerCase()
            }

            fc.selectedFile = File("$newName.d.ts")

            when (fc.showSaveDialog(null)) {
                JFileChooser.APPROVE_OPTION -> {
                    var file = fc.selectedFile

                    println(file.nameWithoutExtension.split('.').last())
                    if (file.extension != "ts" && file.nameWithoutExtension.split('.').last() == "d") {
                        file = File(file.absolutePath + ".d.ts")
                    }

                    file.writeText(fullText)
                }
            }

            fullText = ""
        }

        override fun actionPerformed(e: ActionEvent?) {

            val typeFactory = api!!.getTypeFactory(entry)

            if (typeFactory != null) {
                val type = typeFactory.make(api, entry, fragment)

                if (type != null) {

                    val easyName = type.name.split('/').last()
                    val fullName = type.name.avoidConflictName()
                    println(fullName)

                    fullText += fileHeader
                    fullText += "\n\n"

                    fullText += "declare class $fullName {\n\n"

                    fullText += "  /* fields */\n\n"

                    for (field in type.fields) {
                        fullText += "  "
                        fullText += field.toDefinition()
                        fullText += "\n"
                    }

                    fullText += "\n\n"

                    fullText += "  /* methods */\n\n"

                    for (method in type.methods) {
                        fullText += "  "
                        fullText += method.toDefinition()
                        fullText += "\n"
                    }

                    fullText += "}\n\n"

                    fullText += "export default $fullName"

                    fullText += "\n\n"

                    saveFile(easyName)

                }
            }

        }


    }
}